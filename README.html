<html>
<head>
<title>dsl-pa Documentation</title>
<style type="text/css">
body { font-family: Arial, Helvetica, sans-serif; }
h1 { color:#0005C8; }
h2 { color:#0005C8; }
h3 { color:#0005C8; }
h4 { color:#0005C8; }
code { color:#800000; }
pre.cmd { color:#0000c0; }
pre.code { color:#600000; }
pre.proto { color:#800000; }
pre.anot { color:#0000c0; }
pre.conf { color:#0000c0; }
pre.schema { color:#0000ff; }
pre.xml { color:#0000ff; }
span.xtag { color:#800000; }
span.xattr { color:#ff0000; }
span.ckw { color:#0000ff; }
span.ccom { color:#008000; }
p.content-link { margin-top: 2px; margin-bottom: 4px; border: 2px 0; padding: 2px 0; }
.desc { background-color:#99DAFF; width:100%; padding: 5px; border-width: thin;    border-style: solid; border-color: #99DAFF; }
.synop { color:#0000ff; background-color:#B7E5FF; padding: 5px; }
.flist { background-color:#FFF; padding: 5px; }
.ret { color: #FF9900; text-align: right; }
.fname { color: #800000; }
.args { color: #00f; }
.comment { color: #008000; }
</style>
</head>
<body>
<h1>dsl-pa Documentation</h1>
<p>dsl-pa is a Domain Specific Language Parsing Assistant library designed to
take advantage of the C++ logic shortcut operators such as && and ||.
dsl-pa function calls extract sections of language input based on a
specified alphabet.  Calls to dsl-pa functions are combined using the C++
shortcut operators in order to parse a language in a reasonably compact
form.  Consequently all dsl-pa functions return either a boolean value or
a value, such as an integer, that can be implicitly converted to a bool.
</p>
<p>
Yes, yes, I know, there's not much here.  Give me a chance.
</p>
<p>
P.S. This is a place holder!
</p>
<h2>Project Status</h2>
<p>This project is still under development and NOT yet ready for thrid-party use.</p>

<h1>Character sets</h1>
<p>
The language input is assumed to be in UTF-8 encoding and operations are done on C++ <code>char</code>s.  It is assumed that
any parsing decisions of the input language will be based on the ASCII range of characters and any char valued 0x80 and
above is just considered to be part of "the rest" of Unicode.  Hence dsl-pa operates on a <code>char</code> by <code>char</code> basis and isn't
multi-byte character aware.
</p>
<p>
A value of <code>0</code> is used to indicate the end of input has been reached.
</p>

<h1>Readers</h1>
<h2>Reader locations</h2>
<h3>The location_logger class</h3>

<h1>Alphabets</h1>
<h2>Short alphabet names</h2>

<h1>The dsl_pa class</h1>
<h2>To inherit or not</h2>
<h2>Using C++ shortcut operators</h2>
<h2>dsl_pa helpers</h2>
<h3>dsl_pa::optional()</h3>
<h3>dsl_pa::set()</h3>
<h3>dsl_pa::record()</h3>
<h3>dsl_pa::append()</h3>
<h3>dsl_pa::clear()</h3>
<h3>dsl_pa::error() and dsl_pa::error_fatal()</h3>
</body>
</html>
